* Parlamentsdokumente und Protokollen des Bundestages zum Thema Rechenzentren in Deutschland

Die Protokollen des Bundestages können an der folgenden Adresse als xml-Dateien oder per API heruntergeladen werden: https://www.bundestag.de/services/opendata. Ein Github-Konto bietet ein R-Objekt hier an: https://github.com/benjaminguinaudeau/tidybundestag.
Die Parlamentsdokumente könne per Suche auf der Webseite des Bundestages (DIP) oder per API an der folgenden Adresse bezogen werden: https://www.bundestag.de/parlamentsdokumentation.

Beide Datenbanken liefern unterschiedliche Informationen zu den politischen Entscheidungen, die ab 1949 bis heute auf Bundesebene getroffen werden. Sie erlauben eine Rekonstruktion des thematischen Zusammenhanges, in dem die Rechenzentren in Deutschland definiert und problematisiert wurden. Deshalb ist eine Untersuchung dieser Datenbanken zum Verständnis der Entwicklung von Rechenzentren in Deutschland im Zeitverlauf von Vorteil. Eine solche Untersuchung wird in diesem Dokument anhand von Topic-Modellen und mit dem MTA-Software vorgenommen.

** Vorgehen

Dieses Dokument beschreibt ein Workflow, das die Dokumente in Text-Dateien umwandelt und in mehreren Schritten modelliert. Wir arbeiten mit einem Linux-Betriebssystem -- in diesem Fall Linux Mint mit Kernel 5.4 -- und beziehen die Anwendungen, die diese Familie von Betriebssystemen anbietet. Entsprechende Anpassungen in diesem Dokument müssen unter Windows und MacOS vorgenommen werden. Empfohlen wird für Windows Benutzer die Installation von WSL.

Die Struktur der Quelldateien ist im JSON oder XML Format für die Protokollen und in PDF Format für die Parlamentsdokumente vorhanden. In diesem Workflow verwenden wir die XML Dateien und die PDF Dateien, die sich in unterschiedlichen Ordnern befinden. In einem ersten Schritt wandeln wir die Quelldateien ins Text-Dateien um, d.h.:

 - für die Parlamentsdokumente: von *.pdf zu *.txt;
 - für die Protokollen: von *.xml zu *.txt.

Bibliotheken, die dafür notwendig sind bzw. installiert werden müssen, sind die Folgenden: pandoc, poppler-utils. Weiter in diesem Workflow verwenden wir Python3.x in Verbindung mit dem Software MTA sowie gewöhnliche Bash-Anwendungen (grep, sed, awk, csplit) und die Syntax-Elemente der Bash-Programmiersprache. Zur Interpretation der Ergebnisse der Analyse verwenden wir eine KI auf dem Internet -- in unserem Fall pollinations mit der Anwendung tgpt.

** Dieses Workflow als App benutzen

Dieses Workflow bzw. dieses Dokument kann wie eine Anwendung verwendet werden. Erforderlich dafür ist die Installation vom Texteditor Emacs mit dem Programm Org-mode. Dann kann dieses Workflow auf der Kommandozeile mit dem folgenden Skript meth-bundest.sh ausgeführt werden. Ein solcher Skript wird bei der Evaluation vom folgenden Code-Block dort hergestellt, wo sich der Benutzer befindet.

Zuerst stellen wir eine Variable für den Pfad zum Arbeitsordner her:

#+name: user-path
#+begin_src shell :var userpath="/home/cpsoz/ROM-Data" :results silent
echo $userpath
#+end_src

Dann schreiben wir den Skript:

#+begin_src shell :results silent :var user=user-path
  touch $user/tangle.sh
  echo "#!/bin/bash" >> $user/tangle.sh
  echo 'emacs --batch \' >> $user/tangle.sh
  echo "      --eval \"(require 'org)\" \ " >> $user/tangle.sh
  echo "      --eval \"(setq org-confirm-babel-evaluate nil)\" \ " >> $user/tangle.sh
  echo "      --eval '(org-babel-tangle-file \"WF-Datenzentren-Bundestag.org\")' \ " >> $user/tangle.sh
  chmod +x $user/tangle.sh
#+end_src

Dieser Skript führt alle Code-Blöcke aus. Er wird jedoch die hergestellten Skript im Rahmen von diesen Blöcken nicht ausführen. Wenn das erwünscht ist, dann sollten die Skripts zu tangle.sh hinzugefügt werden (etwa: =sh script.sh=). Ansonsten können die Blöcke in Emacs ausgeführt werden.

* Parlamentsdokumente

** Vorbereitung und Umwandlung

Wir machen eine Sicherheitskopie vom Ordner ParlamentsDoc und vom Ordner XML-Quellen. Wir stellen einen Ordner 'Skripten-Rom' für die Skripten her, die wir brauchen werden.

Wir definieren die Pfade zu den PDF- und XML-Dateien.

#+name: pdfpath
#+begin_src shell :results silent :var pdfpath="/ParlamentsDoc/Parlamentsdokumente_Sozialindex"
echo $pdfpath
#+end_src

#+name: xmlpath
#+begin_src shell :results silent :var xmlpath="/XML-Quellen"
echo $xmlpath
#+end_src

#+begin_src shell :results silent :var xml=xmlpath :var user=user-path :eval no
    cd $user
    cp -a $user/ParlamentsDoc/. $user/ParlamentsDoc_KOPIE/
    cp -a $user/$xml/. XML-Quellen_KOPIE/
    mkdir $user/Skripten-Rom
#+end_src

Wir behalten den Pfad zum Skripten-Ordner in einer Variable 'skriptenpath'

#+name: skriptenpath
#+begin_src shell :results silent :var skriptenpath="/Skripten-Rom"
echo $skriptenpath
#+end_src

Wir wandeln die *.pdf-Dateien der Parlamentsdokumente mit folgendem Skript, den wir im Ordner "Skripten-Walter" speichern.

#+name: pdftxt_parl
#+begin_src shell :results silent :var user=user-path :var skr=skriptenpath
  touch $user/pdftxt.sh
  echo "#!/bin/bash" >> $user/pdftxt.sh
  echo "for i in *.pdf; do pdftotext \"\$i\" ; done"  >> $user/pdftxt.sh
  chmod +x $user/pdftxt.sh
  mv $user/pdftxt.sh $user/$skr
#+end_src

Wir wandeln die Dokumente um.

#+name: umw_parl
#+begin_src shell :results silent :var user=user-path :var parl=pdfpath :var skr=skriptenpath :eval no
  for dir in $user/$parl/*; do [ -d "$dir" ] && cd "$dir" && echo "Entering into $dir and converting files" && bash $user/$skr/pdftxt.sh && rm *.msg && rm *.docx; done;
#+end_src

** Corpus nach Stichwörtern sortieren

In einem zweiten Schritt wollen wir die konvertierten Dateien nach Stichwörtern sortieren und die Ergebnisse in Ordner speichern, die mit diesen Stichwörtern gekennzeichnet werden. Dafür brauchen wir einen Skript, der in alle Ordner geht, und der einen anderen Skript ausführt, der die Dateien sortiert und in die vorgesehenen Ordner speichert.

Der erste Skript sieht wie umw_parl aus, aber er muss einen anderen skript laufen lassen, den wir filter.sh benennen und der die folgenden Zeilen enthält:

#+name: filter_parl
#+begin_src shell :results silent :var user=user-path :var skr=skriptenpath
  touch $user/filter.sh
  echo "#!/bin/bash" >> $user/filter.sh
  echo "words=( \"Rechenzentr\" )" >> $user/filter.sh
  echo "for i in \"\${words[@]}\"; do grep \"\$i\" * | awk -F: '{print \$1}' | uniq > \"\$i\".txt && mkdir \"\$i\"_res && cp \$(<\"\$i\".txt) \"\$i\"_res && rm \"\$i\".txt; done" >> $user/filter.sh
  chmod +x $user/filter.sh
  mv $user/filter.sh $user/$skr
#+end_src

Jetzt können wir unseren umw_parl code anpassen, damit der filter.sh Skript ausgeführt wird

#+name: umw_parl2
#+begin_src shell :results silent :var user=user-path :var parl=pdfpath :var skr=skriptenpath
  for dir in $user/$parl/*; do [ -d "$dir" ] && cd "$dir" && echo "Entering into $dir and converting files" && bash $user/$skr/filter.sh && rm *.msg && rm *.docx; done;
#+end_src

Wir exportieren die Ergebnisse zum Ordner 'Parl-Results' und wir trennen die vier ersten Zahlen (die Jahren) vom Dokumentnamen:

#+name: parl_results
#+begin_src shell :results silent :var parl=pdfpath :var user=user-path
  cd $user && mkdir $user/Parl-Results
  for dir in $user/$parl/*; do cp -rp "$dir"/Rechenzentr_res $user/Parl-Results/; done
  for i in $user/Parl-Results/Rechenzentr_res/*; do mv ./"$i" "${i:0:4}-${i:4}"; done
#+end_src

* Protokollen

Ein Großteil der Arbeit wurde für die Parlamentsdokumente schon erledigt. Für die Protokollen müssen wir nur noch die vorhandenen Skript anpassen. Zuerst müssen wir die Dateien in den jeweiligen Ordner konvertieren. Es sind XML-Dateien, die wir mit Pandoc konvertieren. Dabei wollen wir zwei Zeilen (<div> und <sp> Zeilen) behalten, weil diese Zeilen Metainformationen enthalten, die wir benutzen werden, um die Dateien in einem späteren Schritt zu zerlegen.

** Vorbereitung und Umwandlung

Wir löschen den Ordner 19 in 'XML-Quellen', der anders als die anderen formatiert ist. Wir behandeln diesen Ordner mit einer veränderten Version von parsprot.sh und zerlg-prot.sh (siehe unten).

#+begin_src shell :results silent :var xml=xmlpath :var user=user-path
  rm -r $user/$xml/19
#+end_src

Zuerst erstellen wir den parser, um die XML-Dateien in *.txt-Dateien zu verwandeln und nach TOP zu zerlegen.

#+name: parser_prot
#+begin_src shell :results silent :var user=user-path :var skr=skriptenpath :eval no
  touch $user/parsprot.sh
  echo "#!/bin/bash" >> $user/parsprot.sh
  echo "for i in *.xml; do sed -i 's/<sp /<div /' \"\$i\"; done" >> $user/parsprot.sh
  echo "for i in *.xml; do pandoc -f html -t markdown -s \"\$i\" -o \${i%.*}.txt; done" >> $user/parsprot.sh
  echo "rm *.xml" >> $user/parsprot.sh
  echo "for i in *.txt; do year=\$(sed -n '3,5p' \"\$i\" | awk '\$8{print \$8}') && cp \"\$i\" \"\$year\"_\${i%.*}.fina; done" >> $user/parsprot.sh
  echo "rm *.txt" >> $user/parsprot.sh
  echo "for i in *.fina; do csplit --suppress-matched --prefix \${i%.*} --suffix-format _%03d.txt \"\$i\" '/type=/' '{*}'; done"  >> $user/parsprot.sh
  echo "rm *.fina" >> $user/parsprot.sh
  echo "rm *000_.txt" >> $user/parsprot.sh
  echo "find . -type f -size 0b -delete" >> $user/parsprot.sh
  chmod +x $user/parsprot.sh
  mv $user/parsprot.sh $user/$skr
#+end_src

Wir gehen dann durch alle Ordner und konvertieren die XML-Dateien in *.txt-Dateien, die wir anschließend nach TOP zerlegen. Dies machen wir mit dem folgenden Skript.

#+name: umw_prot
#+begin_src shell :results silent :var xml=xmlpath :var skr=skriptenpath :var user=user-path :eval no
  for dir in $user/$xml/*; do [ -d "$dir" ] && cd "$dir" && echo "Entering into $dir and converting files" && bash $user/$skr/parsprot.sh; done;
#+end_src

Wir haben jetzt eine Datei je TOP. Wir müssen zuerst diese Dateien nach den relevanten Stichwörtern sortieren, bevor wir sie erneute nach Sprechern in den jeweiligen TOP zerlegen. Wir sortieren zuerst die Dateien je Stichwort und dabei benutzen wir den gleichen Skript wie für die Parlamentsdokumente.

#+name: umw_prot2
#+begin_src shell :results silent :var xml=xmlpath :var skr=skriptenpath :var user=user-path
  for dir in $user/$xml/*; do [ -d "$dir" ] && cd "$dir" && echo "Entering into $dir and converting files" && bash $user/$skr/filter.sh; done;
#+end_src

Dann können wir den letzten Schritt machen und die Protokolle nach Sprechern zerlegen sowie die Dateien nach Sprecher/Rolle/Partei umbenennen. Wir brauchen einen neuen Skript für die Zerlegung der Dateien.

#+name: zerleg_prot
#+begin_src shell :results silent :var skr=skriptenpath :var user=user-path
      touch $user/zerleg-prot.sh
      echo "#!/bin/bash" >> $user/zerleg-prot.sh
      echo "for i in *.txt; do csplit --prefix \${i%.*} --suffix-format _%04d.finc \"\$i\" '/who=/' '{*}'; done" >> $user/zerleg-prot.sh
      echo "rm *.txt" >> $user/zerleg-prot.sh
      echo "find . -type f -size 0b -delete" >> $user/zerleg-prot.sh
      echo "for i in *.finc; do nnp=\$(grep \"{who=\" \"\$i\" | sed 's/\" /@/g' | awk -F\"@\" '{print \$1\"-\"\$3\"-\"\$6}' | sed -e 's/\"//g' -e 's/{//g' -e 's/=//g' -e 's/who//g' -e 's/role//g' -e 's/party//g' -e 's/^::: //g' | sed 's/ //g') && cp \"\$i\" \${i%.*}_\"\$nnp\".txt ; done" >> $user/zerleg-prot.sh
      echo "rm *.finc" >> $user/zerleg-prot.sh
      echo "for i in *.txt; do sed -i '/^::: /d' \"\$i\"; done" >> $user/zerleg-prot.sh
      chmod +x $user/zerleg-prot.sh
      mv $user/zerleg-prot.sh $user/$skr
#+end_src

Wir stellen dann einen Ordner 'XML-Results' her, und wir kopieren alle Dateien aus den Unterordnern 'Rechenzentr_res' in diesen Ordner:

#+name: zerleg_results
#+begin_src shell :results silent :var xml=xmlpath :var user=user-path
  cd $user && mkdir $user/XML-Results
  for dir in $user/$xml/*; do cp -rp "$dir"/Rechenzentr_res $user/XML-Results/; done
#+end_src

Wir brauchen ebenfalls einen neuen Skript, um in den Ordner 'XML-Results/Rechenzentr_res' zu gehen, und die Dateien mit dem zerleg-prot.sh Skirpt zu zerlegen:

#+name: enterdirprotres
#+begin_src shell :results none :var user=user-path :var skr=skriptenpath
  cd $user/XML-Results/Rechenzentr_res
  sh $user/$skr/zerleg-prot.sh
#+end_src

Damit haben wir alle relevante Protokolle nach Sprecher, Rolle und Partei zerlegt. 6408 Dateien werden generiert, die wir später mit den anderen Dateien nach Wahlperioden gruppieren werden. Wir müssen noch den Ordner 19 aus den XML-Quellen behandeln.

** Behandlung des Ordners 19

In einem ersten Schritt kopieren wir den Ordner 19 aus der Kopie der XML-Quellen zum Benutzerpfad:

#+begin_src shell :results silent :var user=user-path
  cp -r $user/XML-Quellen_KOPIE/19 $user/
#+end_src

Wir schreiben eine veränderte Version von unserem Parser, um die richtige Position vom Jahr in den XML-Dateien zu treffen:

#+name: parser19_prot
#+begin_src shell :results silent :var user=user-path :var skr=skriptenpath :eval no
  touch $user/parsprot19.sh
  echo "#!/bin/bash" >> $user/parsprot19.sh
  echo "for i in *.xml; do sed -i 's/<sp /<div /' \"\$i\"; done" >> $user/parsprot19.sh
  echo "for i in *.xml; do pandoc -f html -t markdown -s \"\$i\" -o \${i%.*}.txt; done" >> $user/parsprot19.sh
  echo "rm *.xml" >> $user/parsprot19.sh
  echo "for i in *.txt; do year=\$(sed -n '3,5p' \"\$i\" | awk '\$5{print \$5}') && cp \"\$i\" \"\$year\"_\${i%.*}.fina; done" >> $user/parsprot19.sh
  echo "rm *.txt" >> $user/parsprot19.sh
  echo "for i in *.fina; do csplit --suppress-matched --prefix \${i%.*} --suffix-format _%03d.txt \"\$i\" '/type=/' '{*}'; done"  >> $user/parsprot19.sh
  echo "rm *.fina" >> $user/parsprot19.sh
  echo "rm *000_.txt" >> $user/parsprot19.sh
  echo "find . -type f -size 0b -delete" >> $user/parsprot19.sh
  chmod +x $user/parsprot19.sh
  mv $user/parsprot19.sh $user/$skr
#+end_src

Wir konvertieren dann die Dateien in diesem Ordner und wir sortieren sie nach Anwesenheit von unserem Stichwort 'Rechenzentr':

#+name: umw_prot
#+begin_src shell :results silent :var skr=skriptenpath :var user=user-path :eval no
  cd $user/19 && bash $user/$skr/parsprot19.sh && bash $user/$skr/filter.sh
#+end_src

Wir stellen dann einen Ordner '19-Results' her, und wir kopieren alle Dateien aus den Unterordnern 'Rechenzentr_res' in diesen Ordner:

#+name: zerleg19_results
#+begin_src shell :results silent :var user=user-path
  cd $user && mkdir $user/19-Results
  for i in $user/19/Rechenzentr_res/*.txt; do cp "$i" $user/19-Results/; done
#+end_src

Wir brauchen anschließend eine veränderte Version von unserem Skript 'zerleg-prot.sh', da die tags in den Protokollen des Ordners 19 unterschiedlich plaziert sind:

#+name: zerleg19_prot
#+begin_src shell :results silent :var skr=skriptenpath :var user=user-path
      touch $user/zerleg19-prot.sh
      echo "#!/bin/bash" >> $user/zerleg19-prot.sh
      echo "for i in *.txt; do csplit --prefix \${i%.*} --suffix-format _%04d.finc \"\$i\" '/who=/' '{*}'; done" >> $user/zerleg19-prot.sh
      echo "rm *.txt" >> $user/zerleg19-prot.sh
      echo "find . -type f -size 0b -delete" >> $user/zerleg19-prot.sh
      echo "for i in *.finc; do nnp=\$(grep \"{who=\" \"\$i\" | sed 's/\" /@/g' | awk -F\"@\" '{print \$1\"-\"\$3\"-\"\$5}' | sed -e 's/\"//g' -e 's/{//g' -e 's/=//g' -e 's/who//g' -e 's/role//g' -e 's/party//g' -e 's/^::: //g' | sed 's/ //g') && cp \"\$i\" \${i%.*}_\"\$nnp\".txt ; done" >> $user/zerleg19-prot.sh
      echo "rm *.finc" >> $user/zerleg19-prot.sh
      echo "for i in *.txt; do sed -i '/^::: /d' \"\$i\"; done" >> $user/zerleg19-prot.sh
      chmod +x $user/zerleg19-prot.sh
      mv $user/zerleg19-prot.sh $user/$skr
#+end_src

Jetzt können wir mit diesem Skript die Dokumente im Ordner '19-Results' zerlegen:

#+name: enterdirprotres
#+begin_src shell :results none :var user=user-path :var skr=skriptenpath
  cd $user/19-Results
  sh $user/$skr/zerleg19-prot.sh
#+end_src
