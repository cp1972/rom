* Herstellung eines Datensatzes mit den Parlamentsdokumenten und Protokollen des Bundestages zum Thema Rechenzentren in Deutschland

Dieses Dokument stellt ein Workflow dar, das Dokumente in Text-Dateien umwandelt und in mehreren Schritten umbenannt, sortiert und zerlegt. Wir arbeiten mit einem Linux-Betriebssystem -- in der Zeit des Schreibens ist es Linux Mint mit Kernel 5.4 -- und beziehen die Anwendungen, die diese Familie von Betriebssystemen anbietet. Entsprechende Anpassungen in diesem Dokument müssen unter Windows und MacOS vorgenommen werden. Empfohlen wird für Windows-Benutzer die Installation von WSL2.

Die Dokumente sind Parlamentsdokumente der Bundesrepublik Deutschland und Protokollen des Bundestages. Diese Dokumente können an der folgenden Adresse als xml-Dateien, mit einer API oder nach handwerklicher Suche heruntergeladen werden: https://www.bundestag.de/services/opendata.
Ein Github-Konto bietet ein R-Objekt hier an: https://github.com/benjaminguinaudeau/tidybundestag.
Die Parlamentsdokumente könne per Suche auf der Webseite des Bundestages (DIP) oder per API an der folgenden Adresse bezogen werden: https://www.bundestag.de/parlamentsdokumentation.

Mit diesen Dokumenten können Datensätze hergestellt werden, die maschinell untersucht werden können. Inhaltlich liefern diese Dokumente unterschiedliche Informationen zu den politischen Entscheidungen, die von 1949 bis heute auf Bundesebene getroffen werden. Bezogen auf das Thema des Vorhabens in dieser Arbeit erlauben sie eine Rekonstruktion des thematischen Zusammenhanges, in dem die Rechenzentren in Deutschland definiert und problematisiert wurden. Deshalb ist eine Untersuchung dieser Datenbanken zum Verständnis der Entwicklung von Rechenzentren in Deutschland und der Herausforderungen, die damit verbunden sind, vorteilhaft.

Dieses Workflow beschreibt die Stufen zum Aufbau eines solchen Datensatzes und kann als Anwendung verwendet werden (s. u.).

** Vorgehen

Die Quelldateien sind im JSON oder XML Format für die Protokollen sowie in PDF Format für die Parlamentsdokumente verfügbar. In diesem Workflow verwenden wir die XML Dateien und die PDF Dateien, die sich in unterschiedlichen Ordnern befinden. In einem ersten Schritt wandeln wir die Quelldateien ins Text-Dateien um, d.h.:

 - für die Parlamentsdokumente: von *.pdf zu *.txt;
 - für die Protokollen: von *.xml zu *.txt.

Bibliotheken, die dafür notwendig sind bzw. installiert werden müssen, sind die Folgenden: pandoc, poppler-utils. Weiter in diesem Workflow verwenden wir gewöhnliche Bash-Anwendungen (grep, sed, awk, csplit) und die Syntax-Elemente der Bash-Programmiersprache, um die Dateien umzubenennen, zu sortieren und zu zerlegen.

** Dieses Workflow als Anwendung benutzen

Dieses Workflow kann wie eine Anwendung verwendet werden. Erforderlich dafür ist die Installation vom Texteditor Emacs mit Org-mode (ab emacs-28 ist Org-mode im Texteditor und muss nicht separat installiert werden). Dieses Workflow kann auf der Kommandozeile mit dem folgenden Skript 'datab-rech.sh' ausgeführt werden. Ein solcher Skript wird im Arbeitsordner hergestellt, den wir im Folgenden mit diesem Code-Block herstellen:

#+name: user-path
#+begin_src shell :var userpath="/home/cpsoz/ROM-Data" :results silent
echo $userpath
#+end_src

Pfade müssen von Benutzern des Workflows angepasst werden -- statt /home/cpsoz/ROM-Data kann ein anderer Pfad definiert werden.

Dann schreiben wir den 'datab-rech.sh' Skript:

#+begin_src shell :results silent :var user=user-path
  touch $user/datab-rech.sh
  echo "#!/bin/bash" >> $user/datab-rech.sh
  echo 'emacs --batch \' >> $user/datab-rech.sh
  echo "      --eval \"(require 'org)\" \ " >> $user/datab-rech.sh
  echo "      --eval \"(setq org-confirm-babel-evaluate nil)\" \ " >> $user/datab-rech.sh
  echo "      --eval '(org-babel-tangle-file \"WF-Datenzentren-Bundestag.org\")' \ " >> $user/datab-rech.sh
  chmod +x $user/datab-rech.sh
#+end_src

Dieser Skript führt alle Code-Blöcke in diesem Workflow aus. Er kann entsprechend mit bash verwendet werden, etwa: bash datab-rech.sh

Zuerst behandeln wir die Parlamentsdokumente.

* Parlamentsdokumente

** Vorbereitung und Umwandlung

Wir machen eine Sicherheitskopie vom Ordner ParlamentsDoc und vom Ordner XML-Quellen bzw. von den Protokollen des Bundestages. Wir stellen einen Ordner 'Skripten-Rom' für die Skripten her, die wir im Laufe des Workflow produzieren werden.

Wir definieren die Pfade zu den PDF- und XML-Dateien.

#+name: pdfpath
#+begin_src shell :results silent :var pdfpath="/ParlamentsDoc/Parlamentsdokumente_Sozialindex"
echo $pdfpath
#+end_src

#+name: xmlpath
#+begin_src shell :results silent :var xmlpath="/XML-Quellen"
echo $xmlpath
#+end_src

Wir machen eine Kopie der Quelldateien.

#+begin_src shell :results silent :var xml=xmlpath :var user=user-path :eval no
    cd $user
    cp -a $user/ParlamentsDoc/. $user/ParlamentsDoc_KOPIE/
    cp -a $user/$xml/. XML-Quellen_KOPIE/
    mkdir $user/Skripten-Rom
#+end_src

Wir behalten den Pfad zum Skripten-Ordner in einer Variable 'skriptenpath'

#+name: skriptenpath
#+begin_src shell :results silent :var skriptenpath="/Skripten-Rom"
echo $skriptenpath
#+end_src

Wir wandeln die *.pdf-Dateien der Parlamentsdokumente mit folgendem Skript, den wir im Ordner "Skripten-Rom" speichern.

#+name: pdftxt_parl
#+begin_src shell :results silent :var user=user-path :var skr=skriptenpath
  touch $user/pdftxt.sh
  echo "#!/bin/bash" >> $user/pdftxt.sh
  echo "for i in *.pdf; do pdftotext \"\$i\" ; done"  >> $user/pdftxt.sh
  chmod +x $user/pdftxt.sh
  mv $user/pdftxt.sh $user/$skr
#+end_src

Wir wandeln die Parlamentsdokumente um.

#+name: umw_parl
#+begin_src shell :results silent :var user=user-path :var parl=pdfpath :var skr=skriptenpath :eval no
  for dir in $user/$parl/*; do [ -d "$dir" ] && cd "$dir" && echo "Entering into $dir and converting files" && bash $user/$skr/pdftxt.sh && rm *.msg && rm *.docx; done;
#+end_src

** Parlamentsdokumente nach Stichwort sortieren

Wir sortieren die konvertierten Dateien nach einem Stichwort "Rechenzentr", um alle Varianten vom Begriff "Rechenzentrum" (Nominativ, Genitiv, Plural/Einzahlformen) abzufangen. Dafür brauchen wir einen Skript, der in alle Ordner geht, in denen die Dokumente gespeichert sind und nur die Dokumente nimmt, die eine Variante vom erwünschten Begriff enthalten. Diese Dokumente werden in einem Ordner "Rechenzentr_res" gespeichert.

#+name: filter_parl
#+begin_src shell :results silent :var user=user-path :var skr=skriptenpath
  touch $user/filter.sh
  echo "#!/bin/bash" >> $user/filter.sh
  echo "words=( \"Rechenzentr\" )" >> $user/filter.sh
  echo "for i in \"\${words[@]}\"; do grep \"\$i\" * | awk -F: '{print \$1}' | uniq > \"\$i\".txt && mkdir \"\$i\"_res && cp \$(<\"\$i\".txt) \"\$i\"_res && rm \"\$i\".txt; done" >> $user/filter.sh
  chmod +x $user/filter.sh
  mv $user/filter.sh $user/$skr
#+end_src

Wir passen unseren umw_parl Code-Block an, damit der 'filter.sh' Skript richtig ausgeführt wird:

#+name: umw_parl2
#+begin_src shell :results silent :var user=user-path :var parl=pdfpath :var skr=skriptenpath
  for dir in $user/$parl/*; do [ -d "$dir" ] && cd "$dir" && echo "Entering into $dir and sorting files" && bash $user/$skr/filter.sh && rm *.msg && rm *.docx; done;
#+end_src

Wir exportieren die Ergebnisse bzw. die Dateien in den jeweiligen Ordnern "Rechenzentr_res" zu einem Ordner 'Parl-Results' im Arbeitsverzeichnis, und wir trennen die vier ersten Zahlen (die Jahren) des Dokumentnamens vom Rest des Namens mit einem Bindestrich:

#+name: parl_results
#+begin_src shell :results silent :var parl=pdfpath :var user=user-path
  cd $user && mkdir $user/Parl-Results
  for dir in $user/$parl/*; do cp -rp "$dir"/Rechenzentr_res $user/Parl-Results/; done
  for i in $user/Parl-Results/Rechenzentr_res/*; do mv ./"$i" "${i:0:4}-${i:4}"; done
#+end_src

Wir behandeln anschließend die Protokollen des Bundestages.

* Protokollen

Wir müssen die Dateien in den jeweiligen Unterordner (von 01 bis 19) konvertieren. Es sind XML-Dateien, die wir mit Pandoc konvertieren können. Dabei wollen wir zwei Zeilen (<div> und <sp> Zeilen) aus den Quellen behalten, weil diese Zeilen Metainformationen enthalten, die wir benutzen werden, um die Dateien in einem späteren Schritt zu zerlegen.

** Vorbereitung und Umwandlung

Wir löschen den Ordner 19 in 'XML-Quellen', der anders als die anderen formatiert ist. Wir behandeln diesen Ordner mit einer veränderten Version von parsprot.sh und zerlg-prot.sh (s. u.).

#+begin_src shell :results silent :var xml=xmlpath :var user=user-path
  rm -r $user/$xml/19
#+end_src

Zuerst schreiben wir einen Parser, um die XML-Dateien in *.txt-Dateien zu verwandeln und nach Sitzungen und Tagesordnungspunkten (TOP) zu zerlegen.

#+name: parser_prot
#+begin_src shell :results silent :var user=user-path :var skr=skriptenpath
  touch $user/parsprot.sh
  echo "#!/bin/bash" >> $user/parsprot.sh
  echo "for i in *.xml; do sed -i 's/<sp /<div /' \"\$i\"; done" >> $user/parsprot.sh
  echo "for i in *.xml; do pandoc -f html -t markdown -s \"\$i\" -o \${i%.*}.txt; done" >> $user/parsprot.sh
  echo "rm *.xml" >> $user/parsprot.sh
  echo "for i in *.txt; do year=\$(sed -n '3,5p' \"\$i\" | awk '\$8{print \$8}') && cp \"\$i\" \"\$year\"_\${i%.*}.fina; done" >> $user/parsprot.sh
  echo "rm *.txt" >> $user/parsprot.sh
  echo "for i in *.fina; do csplit --suppress-matched --prefix \${i%.*} --suffix-format _%03d.txt \"\$i\" '/type=/' '{*}'; done"  >> $user/parsprot.sh
  echo "rm *.fina" >> $user/parsprot.sh
  echo "rm *000_.txt" >> $user/parsprot.sh
  echo "find . -type f -size 0b -delete" >> $user/parsprot.sh
  chmod +x $user/parsprot.sh
  mv $user/parsprot.sh $user/$skr
#+end_src

Wir gehen dann in alle Ordner und konvertieren die XML-Dateien in *.txt-Dateien, die wir anschließend nach Sitzungen und TOP zerlegen. Dies machen wir mit der folgenden Schleife:

#+name: umw_prot
#+begin_src shell :results silent :var xml=xmlpath :var skr=skriptenpath :var user=user-path
  for dir in $user/$xml/*; do [ -d "$dir" ] && cd "$dir" && echo "Entering into $dir and converting files" && bash $user/$skr/parsprot.sh; done;
#+end_src

Wir haben jetzt eine Datei je Sitzung und TOP. Wir müssen diese Dateien nach dem für uns relevanten Stichwort "Rechenzentr" sortieren, bevor wir sie nach Sprechern in den jeweiligen TOP zerlegen. Wir sortieren zuerst die Dateien je Stichwort und dabei benutzen wir den gleichen Skript wie für die Parlamentsdokumente.

#+name: umw_prot2
#+begin_src shell :results silent :var xml=xmlpath :var skr=skriptenpath :var user=user-path
  for dir in $user/$xml/*; do [ -d "$dir" ] && cd "$dir" && echo "Entering into $dir and sorting files" && bash $user/$skr/filter.sh; done;
#+end_src

Dann können wir den letzten Schritt machen und die Protokolle nach Sprechern zerlegen sowie die Dateien nach Sprecher/Rolle/Partei umbenennen. Wir brauchen einen neuen Skript für die Zerlegung der Dateien.

#+name: zerleg_prot
#+begin_src shell :results silent :var skr=skriptenpath :var user=user-path
      touch $user/zerleg-prot.sh
      echo "#!/bin/bash" >> $user/zerleg-prot.sh
      echo "for i in *.txt; do csplit --prefix \${i%.*} --suffix-format _%04d.finc \"\$i\" '/who=/' '{*}'; done" >> $user/zerleg-prot.sh
      echo "rm *.txt" >> $user/zerleg-prot.sh
      echo "find . -type f -size 0b -delete" >> $user/zerleg-prot.sh
      echo "for i in *.finc; do nnp=\$(grep \"{who=\" \"\$i\" | sed 's/\" /@/g' | awk -F\"@\" '{print \$1\"-\"\$3\"-\"\$6}' | sed -e 's/\"//g' -e 's/{//g' -e 's/=//g' -e 's/who//g' -e 's/role//g' -e 's/party//g' -e 's/^::: //g' | sed 's/ //g') && cp \"\$i\" \${i%.*}_\"\$nnp\".txt ; done" >> $user/zerleg-prot.sh
      echo "rm *.finc" >> $user/zerleg-prot.sh
      echo "for i in *.txt; do sed -i '/^::: /d' \"\$i\"; done" >> $user/zerleg-prot.sh
      chmod +x $user/zerleg-prot.sh
      mv $user/zerleg-prot.sh $user/$skr
#+end_src

Wir stellen einen Ordner 'XML-Results' her, und wir kopieren alle Dateien aus den Unterordnern 'Rechenzentr_res' in diesen Ordner:

#+name: zerleg_results
#+begin_src shell :results silent :var xml=xmlpath :var user=user-path
  cd $user && mkdir $user/XML-Results
  for dir in $user/$xml/*; do cp -rp "$dir"/Rechenzentr_res $user/XML-Results/; done
#+end_src

Wir gehen mit unserem Skript 'zerleg-prot.sh' zum Ordner 'XML-Results/Rechenzentr_res', und wir zerlegen die Dateien:

#+name: enterdirprotres
#+begin_src shell :results none :var user=user-path :var skr=skriptenpath
  cd $user/XML-Results/Rechenzentr_res
  sh $user/$skr/zerleg-prot.sh
#+end_src

Damit haben wir alle relevante Protokolle nach Sprecher, Rolle und Partei zerlegt. 6408 Dateien werden generiert, die wir später mit den anderen Dateien nach Wahlperioden in einem gemeinsamen Ordner gruppieren werden. Wir müssen noch den Ordner 19 aus den XML-Quellen behandeln, der Dateien enthält, die anders als die Dateien in den anderen Ordnern formatiert wurde.

** Behandlung des Ordners 19

In einem ersten Schritt kopieren wir den Ordner 19 aus der Kopie der XML-Quellen zum Benutzerpfad:

#+begin_src shell :results silent :var user=user-path
  cp -r $user/XML-Quellen_KOPIE/19 $user/
#+end_src

Wir schreiben eine veränderte Version von unserem Parser, um die richtige Position vom Jahr in den XML-Dateien zu treffen:

#+name: parser19_prot
#+begin_src shell :results silent :var user=user-path :var skr=skriptenpath :eval no
  touch $user/parsprot19.sh
  echo "#!/bin/bash" >> $user/parsprot19.sh
  echo "for i in *.xml; do sed -i 's/<sp /<div /' \"\$i\"; done" >> $user/parsprot19.sh
  echo "for i in *.xml; do pandoc -f html -t markdown -s \"\$i\" -o \${i%.*}.txt; done" >> $user/parsprot19.sh
  echo "rm *.xml" >> $user/parsprot19.sh
  echo "for i in *.txt; do year=\$(sed -n '3,5p' \"\$i\" | awk '\$5{print \$5}') && cp \"\$i\" \"\$year\"_\${i%.*}.fina; done" >> $user/parsprot19.sh
  echo "rm *.txt" >> $user/parsprot19.sh
  echo "for i in *.fina; do csplit --suppress-matched --prefix \${i%.*} --suffix-format _%03d.txt \"\$i\" '/type=/' '{*}'; done"  >> $user/parsprot19.sh
  echo "rm *.fina" >> $user/parsprot19.sh
  echo "rm *000_.txt" >> $user/parsprot19.sh
  echo "find . -type f -size 0b -delete" >> $user/parsprot19.sh
  chmod +x $user/parsprot19.sh
  mv $user/parsprot19.sh $user/$skr
#+end_src

Wir konvertieren die Dateien in diesem Ordner und wir sortieren sie nach unserem Stichwort "Rechenzentr":

#+name: umw19_prot
#+begin_src shell :results silent :var skr=skriptenpath :var user=user-path :eval no
  cd $user/19 && bash $user/$skr/parsprot19.sh && bash $user/$skr/filter.sh
#+end_src

Wir stellen einen Ordner '19-Results' im Arbeitsverzeichnis her, und wir kopieren alle Dateien aus den Unterordnern 'Rechenzentr_res' in diesen Ordner:

#+name: zerleg19_results
#+begin_src shell :results silent :var user=user-path
  cd $user && mkdir $user/19-Results
  for i in $user/19/Rechenzentr_res/*.txt; do cp "$i" $user/19-Results/; done
#+end_src

Wir brauchen anschließend eine veränderte Version von unserem Skript 'zerleg-prot.sh', da die tags in den Protokollen des Ordners 19 unterschiedlich plaziert sind:

#+name: zerleg19_prot
#+begin_src shell :results silent :var skr=skriptenpath :var user=user-path
      touch $user/zerleg19-prot.sh
      echo "#!/bin/bash" >> $user/zerleg19-prot.sh
      echo "for i in *.txt; do csplit --prefix \${i%.*} --suffix-format _%04d.finc \"\$i\" '/who=/' '{*}'; done" >> $user/zerleg19-prot.sh
      echo "rm *.txt" >> $user/zerleg19-prot.sh
      echo "find . -type f -size 0b -delete" >> $user/zerleg19-prot.sh
      echo "for i in *.finc; do nnp=\$(grep \"{who=\" \"\$i\" | sed 's/\" /@/g' | awk -F\"@\" '{print \$1\"-\"\$3\"-\"\$5}' | sed -e 's/\"//g' -e 's/{//g' -e 's/=//g' -e 's/who//g' -e 's/role//g' -e 's/party//g' -e 's/^::: //g' | sed 's/ //g') && cp \"\$i\" \${i%.*}_\"\$nnp\".txt ; done" >> $user/zerleg19-prot.sh
      echo "rm *.finc" >> $user/zerleg19-prot.sh
      echo "for i in *.txt; do sed -i '/^::: /d' \"\$i\"; done" >> $user/zerleg19-prot.sh
      chmod +x $user/zerleg19-prot.sh
      mv $user/zerleg19-prot.sh $user/$skr
#+end_src

Jetzt können wir mit diesem Skript die Dokumente im Ordner '19-Results' zerlegen:

#+name: enterdirprotres
#+begin_src shell :results none :var user=user-path :var skr=skriptenpath
  cd $user/19-Results
  sh $user/$skr/zerleg19-prot.sh
#+end_src

** Fehlende Protokolle hinzufügen

Im
