* Untersuchung der Protokollen des Bundestages und den Parlamentsdokumenten zum Thema Rechenzentren in Deutschland

Die Protokollen des Bundestages können an der folgenden Adresse als xml-Dateien oder per API heruntergeladen werden: https://www.bundestag.de/services/opendata. Ein Github-Konto bietet ein R-Objekt hier an: https://github.com/benjaminguinaudeau/tidybundestag.
Die Parlamentsdokumente könne per Suche auf der Webseite des Bundestages (DIP) oder per API an der folgenden Adresse bezogen werden: https://www.bundestag.de/parlamentsdokumentation.

Beide Datenbanken liefern unterschiedliche Informationen zu den politischen Entscheidungen, die ab 1949 bis heute auf Bundesebene getroffen werden. Sie erlauben eine Rekonstruktion des thematischen Zusammenhanges, in dem die Rechenzentren in Deutschland definiert und problematisiert wurden. Deshalb ist eine Untersuchung dieser Datenbanken zum Verständnis der Entwicklung von Rechenzentren in Deutschland im Zeitverlauf von Vorteil. Eine solche Untersuchung wird in diesem Dokument anhand von Topic-Modellen und mit dem MTA-Software vorgenommen.

** Vorgehen

Dieses Dokument beschreibt ein Workflow, das die Dokumente in Text-Dateien umwandelt und in mehreren Schritten modelliert. Wir arbeiten mit einem Linux-Betriebssystem -- in diesem Fall Linux Mint mit Kernel 5.4 -- und beziehen die Anwendungen, die diese Familie von Betriebssystemen anbietet. Entsprechende Anpassungen in diesem Dokument müssen unter Windows und MacOS vorgenommen werden. Empfohlen wird für Windows Benutzer die Installation von WSL.

Die Struktur der Quelldateien ist im JSON oder XML Format für die Protokollen und in PDF Format für die Parlamentsdokumente vorhanden. In diesem Workflow verwenden wir die XML Dateien und die PDF Dateien, die sich in unterschiedlichen Ordnern befinden. In einem ersten Schritt wandeln wir die Quelldateien ins Text-Dateien um, d.h.:

 - für die Parlamentsdokumente: von *.pdf zu *.txt;
 - für die Protokollen: von *.xml zu *.txt.

Bibliotheken, die dafür notwendig sind bzw. installiert werden müssen, sind die Folgenden: pandoc, poppler-utils. Weiter in diesem Workflow verwenden wir Python3.x in Verbindung mit dem Software MTA sowie gewöhnliche Bash-Anwendungen (grep, sed, awk, csplit) und die Syntax-Elemente der Bash-Programmiersprache. Zur Interpretation der Ergebnisse der Analyse verwenden wir eine KI auf dem Internet -- in unserem Fall pollinations mit der Anwendung tgpt.

** Dieses Workflow als App benutzen

Dieses Workflow bzw. dieses Dokument kann wie eine Anwendung verwendet werden. Erforderlich dafür ist die Installation vom Texteditor Emacs mit dem Programm Org-mode. Dann kann dieses Workflow auf der Kommandozeile mit dem folgenden Skript meth-bundest.sh ausgeführt werden. Ein solcher Skript wird bei der Evaluation vom folgenden Code-Block dort hergestellt, wo sich der Benutzer befindet.

Zuerst stellen wir eine Variable für den Pfad zum Arbeitsordner her:

#+name: user-path
#+begin_src shell :var userpath="/home/cpsoz/ROM-Data" :results silent
echo $userpath
#+end_src

Dann schreiben wir den Skript:

#+begin_src shell :results silent :var user=user-path
  touch $user/tangle.sh
  echo "#!/bin/bash" >> $user/tangle.sh
  echo 'emacs --batch \' >> $user/tangle.sh
  echo "      --eval \"(require 'org)\" \ " >> $user/tangle.sh
  echo "      --eval \"(setq org-confirm-babel-evaluate nil)\" \ " >> $user/tangle.sh
  echo "      --eval '(org-babel-tangle-file \"WF-Datenzentren-Bundestag.org\")' \ " >> $user/tangle.sh
  chmod +x $user/tangle.sh
#+end_src

Dieser Skript führt alle Code-Blöcke aus. Er wird jedoch die hergestellten Skript im Rahmen von diesen Blöcken nicht ausführen. Wenn das erwünscht ist, dann sollten die Skripts zu tangle.sh hinzugefügt werden (etwa: =sh script.sh=). Ansonsten können die Blöcke in Emacs ausgeführt werden.

* Parlamentsdokumente

** Vorbereitung und Umwandlung

Wir machen eine Sicherheitskopie vom Ordner ParlamentsDoc und vom Ordner XML-Quellen. Wir stellen einen Ordner 'Skripten-Rom' für die Skripten her, die wir brauchen werden.

Wir definieren die Pfade zu den PDF- und XML-Dateien.

#+name: pdfpath
#+begin_src shell :results silent :var pdfpath="/ParlamentsDoc/Parlamentsdokumente_Sozialindex"
echo $pdfpath
#+end_src

#+name: xmlpath
#+begin_src shell :results silent :var xmlpath="/XML-Quellen"
echo $xmlpath
#+end_src

#+begin_src shell :results silent :var xml=xmlpath :var user=user-path :eval no
    cd $user
    cp -a $user/ParlamentsDoc/. $user/ParlamentsDoc_KOPIE/
    cp -a $user/$xml/. XML-Quellen_KOPIE/
    mkdir $user/Skripten-Rom
#+end_src

Wir behalten den Pfad zum Skripten-Ordner in einer Variable 'skriptenpath'

#+name: skriptenpath
#+begin_src shell :results silent :var skriptenpath="/Skripten-Rom"
echo $skriptenpath
#+end_src

Wir wandeln die *.pdf-Dateien der Parlamentsdokumente mit folgendem Skript, den wir im Ordner "Skripten-Walter" speichern.

#+name: pdftxt_parl
#+begin_src shell :results silent :var user=user-path :var skr=skriptenpath
  touch $user/pdftxt.sh
  echo "#!/bin/bash" >> $user/pdftxt.sh
  echo "for i in *.pdf; do pdftotext \"\$i\" ; done"  >> $user/pdftxt.sh
  chmod +x $user/pdftxt.sh
  mv $user/pdftxt.sh $user/$skr
#+end_src

Wir wandeln die Dokumente um.

#+name: umw_parl
#+begin_src shell :results silent :var user=user-path :var parl=pdfpath :var skr=skriptenpath :eval no
  for dir in $user/$parl/*; do [ -d "$dir" ] && cd "$dir" && echo "Entering into $dir and converting files" && bash $user/$skr/pdftxt.sh && rm *.msg && rm *.docx; done;
#+end_src

** Corpus nach Stichwörtern sortieren

In einem zweiten Schritt wollen wir die konvertierten Dateien nach Stichwörtern sortieren und die Ergebnisse in Ordner speichern, die mit diesen Stichwörtern gekennzeichnet werden. Dafür brauchen wir einen Skript, der in alle Ordner geht, und der einen anderen Skript ausführt, der die Dateien sortiert und in die vorgesehenen Ordner speichert.

Der erste Skript sieht wie umw_parl aus, aber er muss einen anderen skript laufen lassen, den wir filter.sh benennen und der die folgenden Zeilen enthält:

#+name: filter_parl
#+begin_src shell :results silent :var user=user-path :var skr=skriptenpath
  touch $user/filter.sh
  echo "#!/bin/bash" >> $user/filter.sh
  echo "words=( \"Rechenzentr\" )" >> $user/filter.sh
  echo "for i in \"\${words[@]}\"; do grep \"\$i\" * | awk -F: '{print \$1}' | uniq > \"\$i\".txt && mkdir \"\$i\"_res && cp \$(<\"\$i\".txt) \"\$i\"_res && rm \"\$i\".txt; done" >> $user/filter.sh
  chmod +x $user/filter.sh
  mv $user/filter.sh $user/$skr
#+end_src

Jetzt können wir unseren umw_parl code anpassen, damit der filter.sh Skript ausgeführt wird

#+name: umw_parl2
#+begin_src shell :results silent :var user=user-path :var parl=pdfpath :var skr=skriptenpath
  for dir in $user/$parl/*; do [ -d "$dir" ] && cd "$dir" && echo "Entering into $dir and converting files" && bash $user/$skr/filter.sh && rm *.msg && rm *.docx; done;
#+end_src

* Protokollen

Ein Großteil der Arbeit wurde für die Parlamentsdokumente schon erledigt. Für die Protokollen müssen wir nur noch die vorhandenen Skript anpassen. Zuerst müssen wir die Dateien in den jeweiligen Ordner konvertieren. Es sind XML-Dateien, die wir mit Pandoc konvertieren. Dabei wollen wir zwei Zeilen (<div> und <sp> Zeilen) behalten, weil diese Zeilen Metainformationen enthalten, die wir benutzen werden, um die Dateien in einem späteren Schritt zu zerlegen.

** Vorbereitung und Umwandlung

Wir löschen den Ordner 19 in 'XML-Quellen', der anders als die anderen formatiert ist. Wir behandeln diesen Ordner mit einer veränderten Version von parsprot.sh und zerlg-prot.sh (siehe unten).

#+begin_src shell :results silent :var xml=xmlpath :var user=user-path
  rm -r $user/$xml/19
#+end_src

Zuerst erstellen wir den parser, um die XML-Dateien in *.txt-Dateien zu verwandeln und nach TOP zu zerlegen.

#+name: parser_prot
#+begin_src shell :results silent :var user=user-path :var skr=skriptenpath :eval no
  touch $user/parsprot.sh
  echo "#!/bin/bash" >> $user/parsprot.sh
  echo "for i in *.xml; do sed -i 's/<sp /<div /' \"\$i\"; done" >> $user/parsprot.sh
  echo "for i in *.xml; do pandoc -f html -t markdown -s \"\$i\" -o \${i%.*}.txt; done" >> $user/parsprot.sh
  echo "rm *.xml" >> $user/parsprot.sh
  echo "for i in *.txt; do year=\$(sed -n '3,5p' \"\$i\" | awk '\$8{print \$8}') && cp \"\$i\" \"\$year\"_\${i%.*}.fina; done" >> $user/parsprot.sh
  echo "rm *.txt" >> $user/parsprot.sh
  echo "for i in *.fina; do csplit --suppress-matched --prefix \${i%.*} --suffix-format _%03d.txt \"\$i\" '/type=/' '{*}'; done"  >> $user/parsprot.sh
  echo "rm *.fina" >> $user/parsprot.sh
  echo "rm *000_.txt" >> $user/parsprot.sh
  echo "find . -type f -size 0b -delete" >> $user/parsprot.sh
  chmod +x $user/parsprot.sh
  mv $user/parsprot.sh $user/$skr
#+end_src

Wir gehen dann durch alle Ordner und konvertieren die XML-Dateien in *.txt-Dateien, die wir anschließend nach TOP zerlegen. Dies machen wir mit dem folgenden Skript.

#+name: umw_prot
#+begin_src shell :results silent :var xml=xmlpath :var skr=skriptenpath :var user=user-path :eval no
  for dir in $user/$xml/*; do [ -d "$dir" ] && cd "$dir" && echo "Entering into $dir and converting files" && bash $user/$skr/parsprot.sh; done;
#+end_src

Wir haben jetzt eine Datei je TOP. Wir müssen zuerst diese Dateien nach den relevanten Stichwörtern sortieren, bevor wir sie erneute nach Sprechern in den jeweiligen TOP zerlegen. Wir sortieren zuerst die Dateien je Stichwort und dabei benutzen wir den gleichen Skript wie für die Parlamentsdokumente.

#+name: umw_prot2
#+begin_src shell :results silent :var xml=xmlpath :var skr=skriptenpath :var user=user-path
  for dir in $user/$xml/*; do [ -d "$dir" ] && cd "$dir" && echo "Entering into $dir and converting files" && bash $user/$skr/filter.sh; done;
#+end_src

Jetzt kopieren wir die

Dann können wir den letzten Schritt machen und die Protokolle nach Sprechern zerlegen sowie die Dateien nach Sprecher/Rolle/Partei umbenennen. Wir brauchen einen neuen Skript für die Zerlegung der Dateien.

#+name: zerleg_prot
#+begin_src shell :results silent :var skr=skriptenpath :var user=user-path
      touch $user/zerleg-prot.sh
      echo "#!/bin/bash" >> $user/zerleg-prot.sh
      echo "for i in *.txt; do csplit --prefix \${i%.*} --suffix-format _%04d.finc \"\$i\" '/who=/' '{*}'; done" >> $user/zerleg-prot.sh
      echo "rm *.txt" >> $user/zerleg-prot.sh
      echo "find . -type f -size 0b -delete" >> $user/zerleg-prot.sh
      echo "for i in *.finc; do nnp=\$(grep \"{who=\" \"\$i\" | sed 's/\" /@/g' | awk -F\"@\" '{print \$1\"-\"\$3\"-\"\$6}' | sed -e 's/\"//g' -e 's/{//g' -e 's/=//g' -e 's/who//g' -e 's/role//g' -e 's/party//g' -e 's/^::: //g' | sed 's/ //g'); done"  >> $user/zerleg-prot.sh
      echo "for i in *.finc; do cp \"\$i\" \${i%.*}_\"\$nnp\".txt ; done" >> $user/zerleg-prot.sh
      echo "rm *.finc" >> $user/zerleg-prot.sh
      echo "for i in *.txt; do sed -i '/^::: /d' \"\$i\"; done" >> $user/zerleg-prot.sh
      chmod +x $user/zerleg-prot.sh
      mv $user/zerleg-prot.sh $user/$skr
#+end_src

Wir stellen dann einen Ordner 'XML-Results' her, und wir kopieren alle Dateien aus den Unterordnern 'Rechenzentr_res' in diesen Ordner:

#+name: zerleg_results
#+begin_src shell :results silent :var xml=xmlpath :var user=user-path
  cd $user && mkdir $user/XML-Results
  for dir in $user/$xml/*; do cp -rp "$dir"/Rechenzentr_res $user/XML-Results/; done
#+end_src

Wir brauchen ebenfalls einen neuen Skript, um in den Ordner 'XML-Results/Rechenzentr_res' zu gehen, und die Dateien mit dem zerleg-prot.sh Skirpt zu zerlegen:

#+name: enterdirprotres
#+begin_src shell :results none :var user=user-path :var skr=skriptenpath
  cd $user/XML-Results/Rechenzentr_res
  sh $user/$skr/zerleg-prot.sh
#+end_src

Damit haben wir alle relevante Protokolle nach Sprecher, Rolle und Partei zerlegt. Es sind mehr als 1 Mio. Dateien, die generiert werden. Eine Idee, um die Komplexität zu reduzieren, besteht darin, dass nur die Protokollteile beibehalten werden, in denen die Stichwörter explizit erwähnt werden. Dafür soll man zuerst den Ordner mit den Ergebnisdateien kopieren:

#+begin_src shell :results silent
  cd ~
  cp -a XML-Quellen/. XML-Quellen-OR/
  mv XML-Quellen XML-Quellen-MR
#+end_src

Damit haben wir einen Ordner 'XML-Quellen-MR' für 'Mit Rausch' und einen Ordner 'XML-Quellen-OR' für 'Ohne Rausch'. Wir wollen jetzt die Dateien im 'OR' Ordner, die das Stichwort nicht enthalten, löschen.

Wir gehen in diesen Ordner 'XML-Quellen-OR':

#+begin_src shell :results silent :var xml=xmlpath
  cd $xml/XML-Quellen-OR/
#+end_src

Wir gehen in den Subordner 01:

#+begin_src shell :results silent :eval no
  cd 01
#+end_src

Wir gehen dann in die jeweiligen Ordner, die die Dateien enthalten -- hier z.B. Forschung_Res:

#+begin_src shell :results silent :eval no
  cd Forschung_Res
#+end_src

Dort führen wir die folgende Schleife aus:

#+begin_src shell :results silent :eval no
  for x in *.txt; do grep -L 'Rechenzentr' "$x" >> bla.txt; done
#+end_src

Wenn die Schleife beendet ist, dann müssen wir die folgende Schleife ausführen:

#+begin_src shell :results silent :eval no
  while IFS= read -r filename; do rm "$filename"; done =< bla.txt
#+end_src

Wir löschen ebenfalls die geschriebene Datei bla.txt: rm bla.txt

#+begin_src shell :results silent :eval no
  rm bla.txt
#+end_src

Dies machen wir mit jedem Ordner, in denen wir unsere Ergebnisse haben, damit die Dateien, die das Stichwort nicht enthalten, gelöscht werden. Entsprechend muss berücksichtigt werden, dass die erste Schleife angepasst werden muss, wenn wir den Ordner wechseln. Wenn wir etwa im Ordner 'Stadt_Res' sind, dann muss die Schleife so aussehen: =for x in *.txt; do grep -L 'Stadt' "$x" >> bla.txt; done=

Wir können das Verfahren wie folgt automatisieren.

Zuerst machen wir einen Skript je Ordner mit dem richtigen Stichwort für die For-Schleife:

#+name forloopres
#+begin_src shell :results silent :var skr=skriptenpath
  touch forsrech.sh
  echo "#!/bin/bash" >> forsrech.sh
  echo "for x in *.txt; do grep -L 'Rechenzentr' \"\$x\" >> bla.txt; done" >> forsrech.sh
  echo "while IFS= read -r filename; do rm \"\$filename\"; done =< bla.txt" >> forsrech.sh
  echo "rm bla.txt"
  chmod +x forsrech.sh
  mv forsrech.sh $skr
#+end_src

Dann können wir zu jedem Unterordner gehen und die Dateien reinigen -- hier ein Beispiel für die zwei ersten Ordner (der Block kann für die anderen Ordner vervollständigt werden):

#+name: cleanres
#+begin_src shell :results silent :var xml=xmlpath :var skr=skriptenpath
  cd $xml/01/Rechenzentr_Res && $skr/forsrech.sh
  cd $xml/02/Rechenzentr_Res && $skr/forsrech.sh
  cd $xml/03/Rechenzentr_Res && $skr/forsrech.sh
  cd $xml/04/Rechenzentr_Res && $skr/forsrech.sh
  cd $xml/05/Rechenzentr_Res && $skr/forsrech.sh
  cd $xml/06/Rechenzentr_Res && $skr/forsrech.sh
  cd $xml/07/Rechenzentr_Res && $skr/forsrech.sh
  cd $xml/08/Rechenzentr_Res && $skr/forsrech.sh
  cd $xml/09/Rechenzentr_Res && $skr/forsrech.sh
  cd $xml/10/Rechenzentr_Res && $skr/forsrech.sh
  cd $xml/11/Rechenzentr_Res && $skr/forsrech.sh
  cd $xml/12/Rechenzentr_Res && $skr/forsrech.sh
  cd $xml/13/Rechenzentr_Res && $skr/forsrech.sh
  cd $xml/14/Rechenzentr_Res && $skr/forsrech.sh
  cd $xml/15/Rechenzentr_Res && $skr/forsrech.sh
  cd $xml/16/Rechenzentr_Res && $skr/forsrech.sh
  cd $xml/17/Rechenzentr_Res && $skr/forsrech.sh
  cd $xml/18/Rechenzentr_Res && $skr/forsrech.sh
  cd $xml/19/Rechenzentr_Res && $skr/forsrech.sh
#+end_src

** Ordner 19 -- Anpassung

Für den Ordner 19 müssen die Skripten parsprot.sh und zerleg-prot.sh wie folgt angepasst werden. Dieser Ordner muss entsprechend von den anderen getrennt behandelt werden:

- parsprot.sh, Zeile: =for i in *.txt; do year=$(sed -n '3,5p' "$i" | awk '$8{print $8}') && cp "$i" "$year"_${i%.*}.fina; done=

  ersetzen mit dieser Zeile: =for i in *.txt; do year=$(sed -n '3,5p' "$i" | awk '$5{print $5}') && cp "$i" "$year"_${i%.*}.fina; done=

- zerleg-prot.sh, Zeile: =for i in *.finc; do nnp=$(grep "{who=" "$i" | sed 's/" /@/g' | awk -F"@" '{print $1"-"$3"-"$6}' | sed -e 's/"//g' -e 's/{//g' -e 's/=//g' -e 's/who//g' -e 's/role//g' -e 's/party//g' -e 's/^::: //g' | sed 's/ //g') && cp "$i" ${i%.*}_"$nnp".txt ; done=

  ersetzen mit dieser Zeile: =for i in *.finc; do nnp=$(grep "{who=" "$i" | sed 's/" /@/g' | awk -F"@" '{print $1"-"$3"-"$5}' | sed -e 's/"//g' -e 's/{//g' -e 's/=//g' -e 's/who//g' -e 's/role//g' -e 's/party//g' -e 's/^::: //g' | sed 's/ //g') && cp "$i" ${i%.*}_"$nnp".txt ; done=

Dann kann man die Skripten im Ordner 19 laufen lassen, und anschließend diesen Ordner im Mutterordner 'XML-Quellen-OR' kopieren und von den unerwünschten Dateien entlasten.
