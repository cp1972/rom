* Herstellung eines Datensatzes mit den Parlamentsdokumenten und Protokollen des Bundestages zum Thema Rechenzentren in Deutschland

Dieses Dokument stellt ein Workflow dar, das Dokumente in Text-Dateien umwandelt und in mehreren Schritten umbenannt, sortiert und zerlegt. Wir arbeiten mit einem Linux-Betriebssystem -- in der Zeit des Schreibens ist es Linux Mint mit Kernel 5.4 -- und beziehen die Anwendungen, die diese Familie von Betriebssystemen anbietet. Entsprechende Anpassungen in diesem Dokument müssen unter Windows und MacOS vorgenommen werden. Empfohlen wird für Windows-Benutzer die Installation von WSL2.

Die Dokumente sind Parlamentsdokumente der Bundesrepublik Deutschland und Protokollen des Bundestages. Diese Dokumente können an der folgenden Adresse als xml-Dateien, mit einer API oder nach handwerklicher Suche heruntergeladen werden: https://www.bundestag.de/services/opendata.
Ein Github-Konto bietet ein R-Objekt hier an: https://github.com/benjaminguinaudeau/tidybundestag.
Die Parlamentsdokumente könne per Suche auf der Webseite des Bundestages (DIP) oder per API an der folgenden Adresse bezogen werden: https://www.bundestag.de/parlamentsdokumentation.

Mit diesen Dokumenten können Datensätze hergestellt werden, die maschinell untersucht werden können. Inhaltlich liefern diese Dokumente unterschiedliche Informationen zu den politischen Entscheidungen, die von 1949 bis heute auf Bundesebene getroffen werden. Bezogen auf das Thema des Vorhabens in dieser Arbeit erlauben sie eine Rekonstruktion des thematischen Zusammenhanges, in dem die Rechenzentren in Deutschland definiert und problematisiert wurden. Deshalb ist eine Untersuchung dieser Datenbanken zum Verständnis der Entwicklung von Rechenzentren in Deutschland und der Herausforderungen, die damit verbunden sind, vorteilhaft.

Dieses Workflow beschreibt die Stufen zum Aufbau eines solchen Datensatzes und kann als Anwendung verwendet werden (s. u.).

** Vorgehen

Die Quelldateien sind im JSON oder XML Format für die Protokollen sowie in PDF Format für die Parlamentsdokumente verfügbar. In diesem Workflow verwenden wir die XML Dateien und die PDF Dateien, die sich in unterschiedlichen Ordnern befinden. In einem ersten Schritt wandeln wir die Quelldateien ins Text-Dateien um, d.h.:

 - für die Parlamentsdokumente: von *.pdf zu *.txt;
 - für die Protokollen: von *.xml zu *.txt.

Bibliotheken, die dafür notwendig sind bzw. installiert werden müssen, sind die Folgenden: pandoc, poppler-utils. Weiter in diesem Workflow verwenden wir gewöhnliche Bash-Anwendungen (grep, sed, awk, csplit) und die Syntax-Elemente der Bash-Programmiersprache, um die Dateien umzubenennen, zu sortieren und zu zerlegen.

** Dieses Workflow als Anwendung benutzen

Dieses Workflow kann wie eine Anwendung verwendet werden. Erforderlich dafür ist die Installation vom Texteditor Emacs mit Org-mode (ab emacs-28 ist Org-mode mit dem Texteditor geliefert und muss nicht separat installiert werden). Dieses Workflow kann auf der Kommandozeile mit dem folgenden Skript 'datab-rech.sh' ausgeführt werden. Ein solcher Skript wird im Arbeitsordner hergestellt, den wir im Folgenden mit diesem Code-Block herstellen:

#+name: user-path
#+begin_src shell :var userpath="/home/cpsoz/ROM-Data" :results silent
echo $userpath
#+end_src

Pfade müssen von Benutzern des Workflows angepasst werden -- statt /home/cpsoz/ROM-Data kann ein anderer Pfad definiert werden.

Dann schreiben wir den 'datab-rech.sh' Skript:

#+begin_src shell :results silent :var user=user-path
  touch $user/datab-rech.sh
  echo "#!/bin/bash" >> $user/datab-rech.sh
  echo "emacs /home/cpsoz/Gitub/rom/Methodologie/01-WF-Rech-BT.org --batch -l /home/cpsoz/.emacs.d/init.el --eval \"(setq org-confirm-babel-evaluate nil)\" --eval \"(org-babel-execute-buffer)\"" >> $user/datab-rech.sh
  chmod +x $user/datab-rech.sh
#+end_src

Dieser Skript führt alle Code-Blöcke in diesem Workflow aus. Er kann entsprechend mit bash verwendet werden, etwa: bash datab-rech.sh
WICHTIG!!!: Damit Pfade korrekt erkannt werden, müssen all die möglichen :results output silenced werden bzw. mussen keine output geschrieben werden, also :results silent

Zuerst behandeln wir die Parlamentsdokumente.

* Parlamentsdokumente

** Vorbereitung und Umwandlung

Wir machen eine Sicherheitskopie vom Ordner ParlamentsDoc und vom Ordner XML-Quellen bzw. von den Protokollen des Bundestages. Wir stellen einen Ordner 'Skripten-Rom' für die Skripten her, die wir im Laufe des Workflow produzieren werden.

Wir definieren die Pfade zu den PDF- und XML-Dateien.

#+name: pdfpath
#+begin_src shell :results silent :var pdfpath="/ParlamentsDoc/Parlamentsdokumente_Sozialindex"
echo $pdfpath
#+end_src

#+name: xmlpath
#+begin_src shell :results silent :var xmlpath="/XML-Quellen"
echo $xmlpath
#+end_src

Wir machen eine Kopie der Quelldateien.

#+begin_src shell :results silent :var xml=xmlpath :var user=user-path :eval no
    cd $user
    cp -a $user/ParlamentsDoc/. $user/ParlamentsDoc_KOPIE/
    cp -a $user/$xml/. XML-Quellen_KOPIE/
    mkdir $user/Skripten-Rom
#+end_src

Wir behalten den Pfad zum Skripten-Ordner in einer Variable 'skriptenpath'

#+name: skriptenpath
#+begin_src shell :results silent :var skriptenpath="/Skripten-Rom"
echo $skriptenpath
#+end_src

Wir wandeln die *.pdf-Dateien der Parlamentsdokumente mit folgendem Skript, den wir im Ordner "Skripten-Rom" speichern.

#+name: pdftxt_parl
#+begin_src shell :results silent :var user=user-path :var skr=skriptenpath
  touch $user/pdftxt.sh
  echo "#!/bin/bash" >> $user/pdftxt.sh
  echo "for i in *.pdf; do pdftotext \"\$i\" ; done"  >> $user/pdftxt.sh
  chmod +x $user/pdftxt.sh
  mv $user/pdftxt.sh $user/$skr
#+end_src

Wir wandeln die Parlamentsdokumente um.

#+name: umw_parl
#+begin_src shell :results silent :var user=user-path :var parl=pdfpath :var skr=skriptenpath :eval no
  for dir in $user/$parl/*; do [ -d "$dir" ] && cd "$dir" && echo "Entering into $dir and converting files" && bash $user/$skr/pdftxt.sh && rm *.msg && rm *.docx; done;
#+end_src

** Parlamentsdokumente nach Stichwort sortieren

Wir sortieren die konvertierten Dateien nach einem Stichwort "Rechenzentr", um alle Varianten vom Begriff "Rechenzentrum" (Nominativ, Genitiv, Plural/Einzahlformen) abzufangen. Dafür brauchen wir einen Skript, der in alle Ordner geht, in denen die Dokumente gespeichert sind und nur die Dokumente nimmt, die eine Variante vom erwünschten Begriff enthalten. Diese Dokumente werden in einem Ordner "Rechenzentr_res" gespeichert.

#+name: filter_parl
#+begin_src shell :results silent :var user=user-path :var skr=skriptenpath
  touch $user/filter.sh
  echo "#!/bin/bash" >> $user/filter.sh
  echo "words=( \"Rechenzentr\" )" >> $user/filter.sh
  echo "for i in \"\${words[@]}\"; do grep \"\$i\" * | awk -F: '{print \$1}' | uniq > \"\$i\".txt && mkdir \"\$i\"_res && cp \$(<\"\$i\".txt) \"\$i\"_res && rm \"\$i\".txt; done" >> $user/filter.sh
  chmod +x $user/filter.sh
  mv $user/filter.sh $user/$skr
#+end_src

Wir passen unseren umw_parl Code-Block an, damit der 'filter.sh' Skript richtig ausgeführt wird:

#+name: umw_parl2
#+begin_src shell :results silent :var user=user-path :var parl=pdfpath :var skr=skriptenpath
  for dir in $user/$parl/*; do [ -d "$dir" ] && cd "$dir" && echo "Entering into $dir and sorting files" && bash $user/$skr/filter.sh && rm *.msg && rm *.docx; done;
#+end_src

Wir exportieren die Ergebnisse bzw. die Dateien in den jeweiligen Ordnern "Rechenzentr_res" zu einem Ordner 'Parl-Results' im Arbeitsverzeichnis, und wir trennen die vier ersten Zahlen (die Jahren) des Dokumentnamens vom Rest des Namens mit einem Bindestrich:

#+name: parl_results
#+begin_src shell :results silent :var parl=pdfpath :var user=user-path
  cd $user && mkdir $user/Parl-Results
  for dir in $user/$parl/*; do cp -rp "$dir"/Rechenzentr_res $user/Parl-Results/; done
  for i in $user/Parl-Results/Rechenzentr_res/*; do mv ./"$i" "${i:0:4}-${i:4}"; done
#+end_src

Wir behandeln anschließend die Protokollen des Bundestages.

* Protokollen

Wir müssen die Dateien in den jeweiligen Unterordner (von 01 bis 19) konvertieren. Es sind XML-Dateien, die wir mit Pandoc konvertieren können. Dabei wollen wir zwei Zeilen (<div> und <sp> Zeilen) aus den Quellen behalten, weil diese Zeilen Metainformationen enthalten, die wir benutzen werden, um die Dateien in einem späteren Schritt zu zerlegen.

** Vorbereitung und Umwandlung

Wir löschen den Ordner 19 in 'XML-Quellen', der anders als die anderen formatiert ist. Wir behandeln diesen Ordner mit einer veränderten Version von parsprot.sh und zerlg-prot.sh (s. u.).

#+begin_src shell :results silent :var xml=xmlpath :var user=user-path
  rm -r $user/$xml/19
#+end_src

Zuerst schreiben wir einen Parser, um die XML-Dateien in *.txt-Dateien zu verwandeln und nach Sitzungen und Tagesordnungspunkten (TOP) zu zerlegen.

#+name: parser_prot
#+begin_src shell :results silent :var user=user-path :var skr=skriptenpath
  touch $user/parsprot.sh
  echo "#!/bin/bash" >> $user/parsprot.sh
  echo "for i in *.xml; do sed -i 's/<sp /<div /' \"\$i\"; done" >> $user/parsprot.sh
  echo "for i in *.xml; do pandoc -f html -t markdown -s \"\$i\" -o \${i%.*}.txt; done" >> $user/parsprot.sh
  echo "rm *.xml" >> $user/parsprot.sh
  echo "for i in *.txt; do year=\$(sed -n '3,5p' \"\$i\" | awk '\$8{print \$8}') && cp \"\$i\" \"\$year\"_\${i%.*}.fina; done" >> $user/parsprot.sh
  echo "rm *.txt" >> $user/parsprot.sh
  echo "for i in *.fina; do csplit --suppress-matched --prefix \${i%.*} --suffix-format _%03d.txt \"\$i\" '/type=/' '{*}'; done"  >> $user/parsprot.sh
  echo "rm *.fina" >> $user/parsprot.sh
  echo "rm *000_.txt" >> $user/parsprot.sh
  echo "find . -type f -size 0b -delete" >> $user/parsprot.sh
  chmod +x $user/parsprot.sh
  mv $user/parsprot.sh $user/$skr
#+end_src

Wir gehen dann in alle Ordner und konvertieren die XML-Dateien in *.txt-Dateien, die wir anschließend nach Sitzungen und TOP zerlegen. Dies machen wir mit der folgenden Schleife:

#+name: umw_prot
#+begin_src shell :results silent :var xml=xmlpath :var skr=skriptenpath :var user=user-path
  for dir in $user/$xml/*; do [ -d "$dir" ] && cd "$dir" && echo "Entering into $dir and converting files" && bash $user/$skr/parsprot.sh; done;
#+end_src

Wir haben jetzt eine Datei je Sitzung und TOP. Wir müssen diese Dateien nach dem für uns relevanten Stichwort "Rechenzentr" sortieren, bevor wir sie nach Sprechern in den jeweiligen TOP zerlegen. Wir sortieren zuerst die Dateien je Stichwort und dabei benutzen wir den gleichen Skript wie für die Parlamentsdokumente.

#+name: umw_prot2
#+begin_src shell :results silent :var xml=xmlpath :var skr=skriptenpath :var user=user-path
  for dir in $user/$xml/*; do [ -d "$dir" ] && cd "$dir" && echo "Entering into $dir and sorting files" && bash $user/$skr/filter.sh; done;
#+end_src

Dann können wir den letzten Schritt machen und die Protokolle nach Sprechern zerlegen sowie die Dateien nach Sprecher/Rolle/Partei umbenennen. Wir brauchen einen neuen Skript für die Zerlegung der Dateien.

#+name: zerleg_prot
#+begin_src shell :results silent :var skr=skriptenpath :var user=user-path
      touch $user/zerleg-prot.sh
      echo "#!/bin/bash" >> $user/zerleg-prot.sh
      echo "for i in *.txt; do csplit --prefix \${i%.*} --suffix-format _%04d.finc \"\$i\" '/who=/' '{*}'; done" >> $user/zerleg-prot.sh
      echo "rm *.txt" >> $user/zerleg-prot.sh
      echo "find . -type f -size 0b -delete" >> $user/zerleg-prot.sh
      echo "for i in *.finc; do nnp=\$(grep \"{who=\" \"\$i\" | sed 's/\" /@/g' | awk -F\"@\" '{print \$1\"-\"\$3\"-\"\$6}' | sed -e 's/\"//g' -e 's/{//g' -e 's/=//g' -e 's/who//g' -e 's/role//g' -e 's/party//g' -e 's/^::: //g' | sed 's/ //g') && cp \"\$i\" \${i%.*}_\"\$nnp\".txt ; done" >> $user/zerleg-prot.sh
      echo "rm *.finc" >> $user/zerleg-prot.sh
      echo "for i in *.txt; do sed -i '/^::: /d' \"\$i\"; done" >> $user/zerleg-prot.sh
      chmod +x $user/zerleg-prot.sh
      mv $user/zerleg-prot.sh $user/$skr
#+end_src

Wir stellen einen Ordner 'XML-Results' her, und wir kopieren alle Dateien aus den Unterordnern 'Rechenzentr_res' in diesen Ordner:

#+name: zerleg_results
#+begin_src shell :results silent :var xml=xmlpath :var user=user-path
  cd $user && mkdir $user/XML-Results
  for dir in $user/$xml/*; do cp -rp "$dir"/Rechenzentr_res $user/XML-Results/; done
#+end_src

Wir gehen mit unserem Skript 'zerleg-prot.sh' zum Ordner 'XML-Results/Rechenzentr_res', und wir zerlegen die Dateien:

#+name: enterdirprotres
#+begin_src shell :results none :var user=user-path :var skr=skriptenpath
  cd $user/XML-Results/Rechenzentr_res
  sh $user/$skr/zerleg-prot.sh
#+end_src

Damit haben wir alle relevante Protokolle nach Sprecher, Rolle und Partei zerlegt. 6408 Dateien werden generiert, die wir später mit den anderen Dateien nach Wahlperioden in einem gemeinsamen Ordner gruppieren werden. Wir müssen noch den Ordner 19 aus den XML-Quellen behandeln, der Dateien enthält, die anders als die Dateien in den anderen Ordnern formatiert wurde.

** Behandlung des Ordners 19

In einem ersten Schritt kopieren wir den Ordner 19 aus der Kopie der XML-Quellen zum Benutzerpfad:

#+begin_src shell :results silent :var user=user-path
  cp -r $user/XML-Quellen_KOPIE/19 $user/
#+end_src

Wir schreiben eine veränderte Version von unserem Parser, um die richtige Position vom Jahr in den XML-Dateien zu treffen:

#+name: parser19_prot
#+begin_src shell :results silent :var user=user-path :var skr=skriptenpath :eval no
  touch $user/parsprot19.sh
  echo "#!/bin/bash" >> $user/parsprot19.sh
  echo "for i in *.xml; do sed -i 's/<sp /<div /' \"\$i\"; done" >> $user/parsprot19.sh
  echo "for i in *.xml; do pandoc -f html -t markdown -s \"\$i\" -o \${i%.*}.txt; done" >> $user/parsprot19.sh
  echo "rm *.xml" >> $user/parsprot19.sh
  echo "for i in *.txt; do year=\$(sed -n '3,5p' \"\$i\" | awk '\$5{print \$5}') && cp \"\$i\" \"\$year\"_\${i%.*}.fina; done" >> $user/parsprot19.sh
  echo "rm *.txt" >> $user/parsprot19.sh
  echo "for i in *.fina; do csplit --suppress-matched --prefix \${i%.*} --suffix-format _%03d.txt \"\$i\" '/type=/' '{*}'; done"  >> $user/parsprot19.sh
  echo "rm *.fina" >> $user/parsprot19.sh
  echo "rm *000_.txt" >> $user/parsprot19.sh
  echo "find . -type f -size 0b -delete" >> $user/parsprot19.sh
  chmod +x $user/parsprot19.sh
  mv $user/parsprot19.sh $user/$skr
#+end_src

Wir konvertieren die Dateien in diesem Ordner und wir sortieren sie nach unserem Stichwort "Rechenzentr":

#+name: umw19_prot
#+begin_src shell :results silent :var skr=skriptenpath :var user=user-path :eval no
  cd $user/19 && bash $user/$skr/parsprot19.sh && bash $user/$skr/filter.sh
#+end_src

Wir stellen einen Ordner '19-Results' im Arbeitsverzeichnis her, und wir kopieren alle Dateien aus den Unterordnern 'Rechenzentr_res' in diesen Ordner:

#+name: zerleg19_results
#+begin_src shell :results silent :var user=user-path
  cd $user && mkdir $user/19-Results
  for i in $user/19/Rechenzentr_res/*.txt; do cp "$i" $user/19-Results/; done
#+end_src

Wir brauchen anschließend eine veränderte Version von unserem Skript 'zerleg-prot.sh', da die tags in den Protokollen des Ordners 19 unterschiedlich plaziert sind:

#+name: zerleg19_prot
#+begin_src shell :results silent :var skr=skriptenpath :var user=user-path
      touch $user/zerleg19-prot.sh
      echo "#!/bin/bash" >> $user/zerleg19-prot.sh
      echo "for i in *.txt; do csplit --prefix \${i%.*} --suffix-format _%04d.finc \"\$i\" '/who=/' '{*}'; done" >> $user/zerleg19-prot.sh
      echo "rm *.txt" >> $user/zerleg19-prot.sh
      echo "find . -type f -size 0b -delete" >> $user/zerleg19-prot.sh
      echo "for i in *.finc; do nnp=\$(grep \"{who=\" \"\$i\" | sed 's/\" /@/g' | awk -F\"@\" '{print \$1\"-\"\$3\"-\"\$5}' | sed -e 's/\"//g' -e 's/{//g' -e 's/=//g' -e 's/who//g' -e 's/role//g' -e 's/party//g' -e 's/^::: //g' | sed 's/ //g') && cp \"\$i\" \${i%.*}_\"\$nnp\".txt ; done" >> $user/zerleg19-prot.sh
      echo "rm *.finc" >> $user/zerleg19-prot.sh
      echo "for i in *.txt; do sed -i '/^::: /d' \"\$i\"; done" >> $user/zerleg19-prot.sh
      chmod +x $user/zerleg19-prot.sh
      mv $user/zerleg19-prot.sh $user/$skr
#+end_src

Jetzt können wir mit diesem Skript die Dokumente im Ordner '19-Results' zerlegen:

#+name: enterdirprotres
#+begin_src shell :results none :var user=user-path :var skr=skriptenpath
  cd $user/19-Results
  sh $user/$skr/zerleg19-prot.sh
#+end_src

** Fehlende Protokolle hinzufügen

In unserer Version der Protokollen des Bundestages gehen die Dateien von 1949 bis zum 17.05.2023. Die weiteren Protokollen haben wir mit Verwendung der Suchmaschine auf der Webseite des Bundestages als XML-Dateien handwerklich heruntergeladen und in *.txt-Dateien umgewandelt. Die Suche mit der Suchmaschine ergibt die Dateien mit den spezifischen Passagen aus den Protokollen, die das Stichwort "Rechenzentr" enthalten, weshalb wir keine volle Protokollen heruntergeladen haben, sondern die Ergebnisdokumente mit den betreffenden Stellen. Diese Dateien sind Fragen an den Bundestag, Antworten vom Bundestag, Unterrichtungen, Berichte, Gesetzentwürfe, Beschlussempfehlungen, Entschliessungsanträge, die keine besondere tags enthalten.

Wir speichern diese Dateien in einem Ordner 'ROM-Data-2023-2025' für die Zeit der Erfassung der Protokollen (Juni 2025), und diesen Ordner kopieren wir in unseren Arbeitsordner:

#+name: data23-25
#+begin_src shell :var user=user-path :results silent
cp -r /home/cpsoz/ROM-Data-2023-2025 $user
#+end_src

Wir wandeln die *.xml-Dateien in *.txt-Dateien:

#+name: umw-data2325
#+begin_src shell :var user=user-path :results silent
  cd $user/ROM-Data-2023-2025
  for i in *.xml; do pandoc -f html -t markdown -s "$i" -o ${i%.*}.txt; done
  rm *.xml
#+end_src

** Zusammenführung der Dateien

Unsere Dateien befinden sich in drei unterschiedlichen Ordnern, weshalb wir sie in einem gemeinsamen Ordner speichern möchten. Dafür stellen wir den gemeinsamen Ordner 'Rechenzentren' mit folgenden Zeilen her:

#+name: rechenordner
#+begin_src shell :var user=user-path :results silent
  cd $user && mkdir Rechenzentren
#+end_src

Wir kopieren die Dateien von den drei 'Results' Ordner zu unserem Rechenzentren-Ordner.

#+name: kop-rechenordner
#+begin_src shell :var user=user-path :results silent
  cp $user/19-Results/* $user/Rechenzentren
  cp $user/Parl-Results/Rechenzentr_res/* $user/Rechenzentren
  cp $user/XML-Results/Rechenzentr_res/* $user/Rechenzentren
#+end_src

Wir wollen die Dateien je Legislaturperiode bzw. Wahlperiode anordnen. Dafür stellen wir Ordner mit 01 für die erste Wahlperiode bis 20 für die vorletzte Wahlperiode (Dateien von 2025 gehen zu 20, selbst wenn ab Mai 2025 die 21. Wahlperiode anfängt):

#+name: wahlp1-21
#+begin_src shell :var user=user-path :results silent
  cd $user/Rechenzentren
  mkdir 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20
#+end_src

Wir verschieben dann die Dateien zu den geeigneten Wahlperioden und wir löschen die möglichen leeren Ordner:

#+name: wahlmv
#+begin_src shell :var user=user-path :results none
  cd $user/Rechenzentren
  mv {1949..1953}*.txt 01
  mv {1954..1957}*.txt 02
  mv {1958..1961}*.txt 03
  mv {1962..1965}*.txt 04
  mv {1966..1969}*.txt 05
  mv {1970..1972}*.txt 06
  mv {1973..1976}*.txt 07
  mv {1977..1980}*.txt 08
  mv {1981..1983}*.txt 09
  mv {1984..1987}*.txt 10
  mv {1988..1990}*.txt 11
  mv {1991..1994}*.txt 12
  mv {1995..1998}*.txt 13
  mv {1999..2002}*.txt 14
  mv {2003..2005}*.txt 15
  mv {2006..2009}*.txt 16
  mv {2010..2013}*.txt 17
  mv {2014..2017}*.txt 18
  mv {2018..2021}*.txt 19
  mv {2022..2025}*.txt 20
  find . -type d -empty -delete
#+end_src

Unser Datensatz ist jetzt bereit und kann analysiert werden. Dies erfolgt im einem [[file+sys:~/Github/rom/Methodologie/02-WF-Rech-TM.org][zweiten Workflow]].
